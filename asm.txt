файл io.asm
; Модуль загрузки и сохранения из/в файл

model small
.stack 100h
.data
    buffer_size     equ 1600
    buffer          dw buffer_size, ?, buffer_size dup(?) ; Буффер
    result_exists   db 0

    handle1         dw 0 ; Дескриптор файла 1
    handle2         dw 0 ; Дескриптор файла 2

    file_length     equ 50 ; Длинна вводимого пути файлов
    input_file      db file_length, ?, file_length dup(0)
    output_file     db file_length, ?, file_length dup(0)
    result_file     db 12 dup(0) ; Temp файл для хранения результата

    file_input_str  db 'Input filename: ',10,13,'$'
    file_error_str  db 'Error while processing file. ;-(',10,13,'$' 

    error1_str      db 10,13,'Error while processing file',10,13,'$'
    error2_str      db 10,13,'Path not found',10,13,'$' 
    error3_str      db 10,13,'Too much opened files',10,13,'$'
    error4_str      db 10,13,'Permission denied',10,13,'$'
.code
.486

extrn work:near
extrn print_no_result:near
extrn rand:near
extrn seed:word

public flush
public buffer

public io_file_read
public io_file_save

public io_result_true
public io_result_false

public print_result

; =============== Загрузка строк из файла ===============

io_file_read proc near
    call flush
    
    ; Создаем temp файл
    ; он будет создан в текущей директории (./)
    mov result_file[0], "."
    mov result_file[1], "/"

    mov ah, 5Ah
    lea dx, result_file
    mov cx, 02h ; Скрытый файл (⌐■_■)
    int 21h
    mov bx, ax
    mov ah, 3Eh
    int 21h

    lea dx, file_input_str
    mov ah, 9
    int 21h

    lea dx, input_file
    mov ah, 0ah
    int 21h

    mov si, 1

; Удаляем enter, иначе файл не будет обработан
io_file_read_remove_enter:
    inc si
    cmp input_file[esi], 0Dh
    jne io_file_read_remove_enter

    mov input_file[esi], 0h
    xor si, si

    mov ax, 3d00h ; Открываем для чтения
    lea dx, input_file ; DS:DX указатель на имя файла
    add dx, 2
    int 21h ; В ax деcкриптор файла
    jc io_file_error ; Если поднят флаг С, то ошибка открытия

    mov handle1, ax ; Сохраняем указатель файла
    mov bx, handle1
    xor cx, cx
    xor dx, dx
    mov ax, 4200h
    int 21h ; Идем к началу файла
    lea dx, buffer
    lea si, buffer ; Нужно для lodsb

io_file_read_loop:
    mov ah, 3fh ; Будем читать из файла
    mov cx, 1 ; 1 байт
    int 21h

    cmp ax, cx ; Если достигнут EoF или ошибка чтения
    jnz io_file_read_close ; То закрываем файл

    lodsb

    cmp al, 0Dh
    je io_file_read_work ; Конец строки

    mov ax, 4200h
    inc dx

    jmp io_file_read_loop

io_file_read_work:
    ; Сохраняем дескриптор к стеке
    push handle1

    call work

    ; Восстанавливаем нужное место
    pop bx
    lea dx, buffer
    lea si, buffer
    
    ; Пропускаем 0Ah (CL/RF)
    dec dx
    dec si

    jmp io_file_read_loop

io_file_read_close: ; Закрываем файл, после чтения
    mov result_exists, 1

    mov ah, 3eh
    mov bx, handle1
    int 21h

    ; Самостоятельно записываем 0Dh,
    ; иначе обработка не найдет конец строки
    mov ax, 000Dh
    mov [esi], eax
    call work

    ret
io_file_read endp

; =============== Сохранение файла ===============

io_file_save proc near
    cmp result_exists, 0 ; Проверяем, есть ли результат
    je print_result_error

    lea dx, file_input_str
    mov ah, 9
    int 21h

    lea dx, output_file
    mov ah, 0ah
    int 21h

    mov bx, 1

io_file_save_remove_enter:
    inc bx
    cmp output_file[ebx], 0Dh
    jne io_file_save_remove_enter

    mov output_file[ebx], 0h

    mov ah, 3Ch ; Функция DOS 3Ch (создание файла)
    lea dx, output_file
    add dx, 2
    xor cx, cx ; Нет атрибутов - обычный файл
    int 21h
    jc io_file_error

    mov handle1, ax

    mov ax, 3d00h
    lea dx, result_file
    int 21h

    mov handle2, ax

io_file_save_process:
    ; Считали
    mov ah, 3Fh
    mov cx, 1
    mov bx, handle2
    lea dx, buffer
    int 21h
    
    cmp ax, cx ; Если достигнут EoF или ошибка чтения
    jc io_file_save_close ; То закрываем файл

    ; Записали
    mov ah, 40h
    mov cx, 1
    mov bx, handle1
    int 21h

    jmp io_file_save_process

io_file_save_close:
    ; Закрыли все файлы
    mov ah, 3eh
    mov bx, handle1
    int 21h

    mov ah, 3eh
    mov bx, handle2
    int 21h

    ret
io_file_save endp

; =============== Ошибка обработки файла ===============

io_file_error:
    call process_error
    ret
    
process_error proc
    cmp ax, 3
    je error2
    cmp ax, 4
    je error3
    cmp ax, 5
    je error4

error1:
    mov ah, 9h
    lea dx, error1_str
    int 21h
    ret

error2:
    mov ah, 9h
    lea dx, error2_str
    int 21h
    ret

error3:
    mov ah, 9h
    lea dx, error3_str
    int 21h
    ret

error4:
    mov ah, 9h
    lea dx, error4_str
    int 21h
    ret
process_error endp
    
; =============== Сохранение и выгрузка результата ===============

io_result_true proc near
    call io_result_open
    lea dx, buffer
    mov buffer[0], 31h
    call io_result_write

    ret
io_result_true endp

io_result_false proc near
    call io_result_open
    lea dx, buffer
    mov buffer[0], 30h
    call io_result_write

    ret
io_result_false endp

io_result_open:
    mov ax, 3D01h ; Открываем для записи
    lea dx, result_file
    int 21h

    mov bx, ax

    mov ax, 4202h
    xor dx, dx
    xor cx, cx
    int 21h

    ret
    
io_result_write:
    mov ah, 40h ; Функция DOS 40h (запись в файл)
    mov cx, 1
    int 21h

    mov ah, 3Eh ; Закрытие файла
    int 21h

    ret

; =============== Вывод результата на экран ===============

print_result proc near
    cmp result_exists, 0 ; Проверяем, есть ли результат
    je print_result_error

    mov ax, 3d00h ; Открываем для чтения
    lea dx, result_file ; DS:DX указатель на имя файла
    int 21h

    mov handle1, ax

print_result_loop:
    mov ah, 3Fh ; Чтение из файла
    mov cx, 1
    mov bx, handle1
    mov dx, buffer[0]
    int 21h

    cmp ax, cx ; Если достигнут EoF или ошибка чтения
    jc print_result_close ; То закрываем файл

    mov ah, 9
    ; Помещаем в конец считанной строки символ конца строки ($),
    ; иначе при выводе не будет найден конец и будет выведена
    ; куча мусора из памяти
    mov esi, "$"
    mov [edx+1], esi
    int 21h ; Вывод

    jmp print_result_loop

print_result_error:
    call print_no_result
    ret

print_result_close:
    mov ah, 3eh
    mov bx, handle1
    int 21h
    ret
print_result endp

; =============== Очистка результата ===============

flush proc near
    mov result_exists, 0

    ; Удаляем temp файл
    mov ah, 41h
    lea dx, result_file
    int 21h

    xor si, si
    mov cx, 12

flush_result:
    mov result_file[si], 0h
    inc si
    loop flush_result

    mov cx, buffer_size
    xor si, si

flush_buffer:
    mov buffer[si], 03h
    inc si
    loop flush_buffer

    mov cx, file_length
    mov si, 2

flush_input_file:
    mov input_file[si], 0h
    inc si
    loop flush_input_file

    mov cx, file_length
    mov si, 2

flush_output_file:
    mov output_file[si], 0h
    inc si
    loop flush_output_file

    ret
flush endp

exit:
    ret

end

файл main.asm
; Для каждой строки построить цифровую подпись
; посредством суммирования всех символов по модулю 2^64.

; Использовать полученные сигнатуры
; для проверки подлинности других строк.

model small
.stack 100h
.data
    main_string   db 255, ?, 255 dup("$") ; Главная строка
    tmp           db 2, ?, 2 dup(0) ; Хранение ввода пункта меню

    sum           dd 0b ; Хеши строк
    main_sum      dd 0b ; Хеш главной строки

    part1         dd 0b
    part2         dd 0b

    input_string  db 'Input string:',10,13,"$"

; ================================================================================

.code
.486

extrn print_menu:near
extrn print_result:near
extrn print_no_input:near
extrn print_no_string:near
extrn print_no_result:near

extrn io_file_read:near
extrn io_file_save:near

extrn io_result_true:near
extrn io_result_false:near

extrn flush:near

extrn buffer:byte

public work

start:
    mov ax, @data
    mov ds, ax

; =============== Контрольная позиция ===============

main:
    call print_menu ; Вызываем вывод меню на экран

    lea dx, tmp
    mov ah, 0ah
    int 21h

process: ; Обработка введенного пункта меню
    cmp tmp[2], '0'
    je exit
    cmp tmp[2], '1'
    je main
    cmp tmp[2], '2'
    je new_string
    cmp tmp[2], '3'
    je file_read
    cmp tmp[2], '4'
    je file_save
    cmp tmp[2], '5'
    je output

    call print_no_input
    jmp main

; =============== Ввод главной строки ===============

new_string:
    lea dx, input_string
    mov ah, 9
    int 21h

    lea dx, main_string
    mov ah, 0ah
    int 21h

    mov main_sum, 0b
    mov si, 2

new_string_loop:
    lodsb

    cmp al, 0Dh ; Проверка на конец строки
    je main

    call work_quadruple
    
    add main_sum, edx

    jmp new_string_loop

; =============== Обработка строк ===============

work proc near
    xor ax, ax
    xor si, si

    mov sum, 0

work_sign:
    mov al, buffer[esi]

    ; Конец строки
    cmp ax, 0Dh
    je work_compare

    call work_quadruple
    
    add sum, edx

    inc si

    jmp work_sign

work_quadruple:
    cbw  ; al  -> ax
    cwde ; ax  -> eax
    cdq  ; eax -> edx:eax

    mov part1, eax
    mov part2, edx
    
    xor edx, edx

    add edx, part1
    add edx, part2

    ret

work_compare:
    mov eax, sum
    mov ebx, main_sum

    cmp eax, ebx
    jne work_write_false
    je work_write_true

work_write_true:
    call io_result_true
    ret
    
work_write_false:
    call io_result_false
    ret
work endp

; =============== Загрузка из файла ===============

file_read:
    cmp main_string[2], "$" ; Проверяем, есть ли  главная строка
    je no_string
    call io_file_read
    jmp main

; =============== Сохранение файла ===============

file_save:
    call io_file_save
    jmp main

; =============== Разное ===============

; Вывод результата на экран
output:
    call print_result
    jmp main

; Отсутствует главная строка
no_string:
    call print_no_string
    jmp main

; =============== Конец программы ===============

exit:
    call flush
    mov ax, 4c00h
    int 21h

end

файл menu.asm
; Модуль вывода меню

model small
.stack 100h
.data
    menu_space       db 10,13,10,13,"$"
    menu_exit        db '0. Exit',10,13,"$"
    menu_print       db '1. Print menu',10,13,"$"
    menu_enter       db '2. Enter string',10,13,"$"
    menu_load        db '3. Load strings from file',10,13,"$"
    menu_save        db '4. Save to file',10,13,"$"
    menu_output      db '5. Output',10,13,"$"
    menu_choose      db 'Select option:',10,13,"$"

    menu_error       db 'There are no such option in menu. Are you sure that you wrote correct number, man?',10,13,"$"
    menu_no_string   db 'Please input main string firstly',10,13,"$"
    menu_no_result   db 'No result. Load strings from file and run again',10,13,"$"

.code
.486

extrn result:byte

public print_menu
public print_no_input
public print_no_string
public print_no_result

print_menu proc near
    mov dx, offset menu_space ; Пробел
    mov ah, 9
    int 21h
    mov dx, offset menu_exit ; Выход из программы
    mov ah, 9
    int 21h
    mov dx, offset menu_print ; Вывод меню
    mov ah, 9
    int 21h
    mov dx, offset menu_enter ; Ввод основной строки
    mov ah, 9
    int 21h
    mov dx, offset menu_load ; Загрузка строк из файла
    mov ah, 9
    int 21h
    mov dx, offset menu_save ; Сохранить в файл результат
    mov ah, 9
    int 21h
    mov dx, offset menu_output ; Вывод результата на экран
    mov ah, 9
    int 21h
    mov dx, offset menu_choose ; Выбор пункта меню
    mov ah, 9
    int 21h

    ret
print_menu endp

; =============== Отсутствует главная строка ===============

print_no_string proc near
    mov dx, offset menu_space ; Пробел
    mov ah, 9
    int 21h

    mov dx, offset menu_no_string
    mov ah, 9
    int 21h

    ret
print_no_string endp

; =============== Отсутствует результат ===============

print_no_result proc near
    mov dx, offset menu_space ; Пробел
    mov ah, 9
    int 21h

    mov dx, offset menu_no_result
    mov ah, 9
    int 21h

    ret
print_no_result endp

; =============== В меню ничего не выбрано ===============

print_no_input proc near
    mov dx, offset menu_space ; Пробел
    mov ah, 9
    int 21h

    mov dx, offset menu_error
    mov ah, 9
    int 21h

    ret
print_no_input endp

exit:
    ret

end
